y = Lambda(kernelEstCKT$estimatedCKT[whichNotFinite]),
family = "gaussian")
designMatrixZ[whichNotFinite, ]
Lambda(kernelEstCKT$estimatedCKT[whichNotFinite]
)
whichFinite = which( is.finite(kernelEstCKT$estimatedCKT))
if (is.null(whichFinite)) {
stop("No kernel estimation successful. ",
"Maybe h_kernel is too small?")
}
fit = glmnet::glmnet(x = designMatrixZ[whichFinite, ],
y = Lambda(kernelEstCKT$estimatedCKT[whichFinite]),
family = "gaussian")
if (is.null(lambda)){
resultCV <- CKT.KendallReg.LambdaCV(
observedX1 = observedX1, observedX2 = observedX1,
observedZ = observedZ, ZToEstimate = ZToEstimate,
designMatrixZ = designMatrixZ,
typeEstCKT = 4, Lambda = Lambda, h_lambda = h_lambda, kernel.name = "Epa",
Kfolds_lambda = Kfolds_lambda, l_norm = l_norm)
lambda <- resultCV$lambdaCV
}
#' # and estimated Kendall's tau (in red)
#' trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
#' plot(newZ, trueConditionalTau , col="black",
#'    type = "l", ylim = c(-1, 1))
#' lines(newZ, estimatedCKT_kendallReg, col = "red")
#'
#'
#'
#' @export
#'
CKT.kendallReg.fit <- function(
observedX1, observedX2, observedZ,
newDataZ, ZToEstimate = newDataZ,
designMatrixZ = cbind(ZToEstimate, ZToEstimate^2),
h_kernel,
Lambda = identity, Lambda_inv = identity,
lambda = NULL, Kfolds_lambda = 10, l_norm = 1, h_lambda = NULL, ...)
{
kernelEstCKT = CKT.kernel(
observedX1 = observedX1, observedX2 = observedX2,
observedZ = observedZ, newZ = ZToEstimate, h = h_kernel, ...)
whichFinite = which( is.finite(kernelEstCKT$estimatedCKT))
if (is.null(whichFinite)) {
stop("No kernel estimation successful. ",
"Maybe h_kernel is too small?")
}
fit = glmnet::glmnet(x = designMatrixZ[whichFinite, ],
y = Lambda(kernelEstCKT$estimatedCKT[whichFinite]),
family = "gaussian")
if (is.null(lambda)){
resultCV <- CKT.KendallReg.LambdaCV(
observedX1 = observedX1, observedX2 = observedX1,
observedZ = observedZ, ZToEstimate = ZToEstimate,
designMatrixZ = designMatrixZ,
typeEstCKT = 4, Lambda = Lambda, h_lambda = h_lambda, kernel.name = "Epa",
Kfolds_lambda = Kfolds_lambda, l_norm = l_norm)
lambda <- resultCV$lambdaCV
}
estimatedCKT = CKT.kendallReg.predict(fit = fit, newDataZ = newDataZ,
lambda = lambda, Lambda_inv = Lambda_inv)
return (list(estimatedCKT = estimatedCKT,
fit = fit))
}
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newDataZ = newZ, h_kernel = 0.07)
designMatrixZ = designMatrixZ
n = length(observedX1)
nZprime = length(ZToEstimate)
matrixSignsPairs = computeMatrixSignPairs(
vectorX1 = observedX1, vectorX2 = observedX2, typeEstCKT = typeEstCKT)
#'  where \eqn{1} is the indicator function.
#'
#' For typeEstCKT = 1 (resp. typeEstCKT = 3)
#' a negatively biased (resp. positively) matrix is given.
#'
#' @return an \eqn{n * n} matrix with the signs of each pair
#' of observations.
#'
#' @keywords internal
#'
computeMatrixSignPairs <- function(vectorX1, vectorX2, typeEstCKT)
{
if (length(vectorX1) != length(vectorX2)) {
stop(paste0("vectorX1 and vectorX2 have different lengths: ",
length(vectorX1), " and ", length(vectorX2)))
}
n = length(vectorX1)
matrixSignsPairs = matrix(nrow = n, ncol = n)
if (typeEstCKT == 1)
{
for (i in (1:(n-1)))
{
matrixSignsPairs[i,i] = 0
matrixSignsPairs[i,(i+1):n] = as.numeric(
vectorX1[i] < vectorX1[(i+1):n] & vectorX2[i] < vectorX2[(i+1):n] )
matrixSignsPairs[(i+1):n,i] = as.numeric(
vectorX1[(i+1):n] < vectorX1[i] & vectorX2[(i+1):n] < vectorX2[i] )
}
} else if (typeEstCKT %in% c(2,4) ) {
for (i in (1:(n-1)))
{
matrixSignsPairs[i,i] = 0
signVector = (vectorX1[i] - vectorX1[(i+1):n]) *
(vectorX2[i] - vectorX2[(i+1):n])
matrixSignsPairs[i,(i+1):n] =
as.numeric( signVector > 0) -as.numeric( signVector < 0)
matrixSignsPairs[(i+1):n,i] = matrixSignsPairs[i,(i+1):n]
}
} else if (typeEstCKT == 3) {
for (i in (1:(n-1)))
{
matrixSignsPairs[i,i] = 0
matrixSignsPairs[i,(i+1):n] = as.numeric(
vectorX1[i] < vectorX1[(i+1):n] & vectorX2[i] > vectorX2[(i+1):n] )
matrixSignsPairs[(i+1):n,i] = as.numeric(
vectorX1[(i+1):n] < vectorX1[i] & vectorX2[(i+1):n] > vectorX2[i] )
}
} else {stop(paste0("typeEstCKT: ", typeEstCKT, " is not in {1,2,3,4}" ) ) }
matrixSignsPairs[n,n] = 0
return (matrixSignsPairs)
}
matrixSignsPairs = computeMatrixSignPairs(
vectorX1 = observedX1, vectorX2 = observedX2, typeEstCKT = typeEstCKT)
typeEstCKT = 4
matrixSignsPairs = computeMatrixSignPairs(
vectorX1 = observedX1, vectorX2 = observedX2, typeEstCKT = typeEstCKT)
if (is.vector(observedZ)){
estimCKTNP <- CKT.kernel.univariate
} else {
estimCKTNP <- CKT.kernel.multivariate
}
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.kernel.R', encoding = 'UTF-8')
if (is.vector(observedZ)){
estimCKTNP <- CKT.kernel.univariate
} else {
estimCKTNP <- CKT.kernel.multivariate
}
foldid = sample(rep(seq(Kfolds_lambda), length = n))
list_vectorEstimate = as.list(seq(Kfolds_lambda))
list_vectorEstimate_comp = as.list(seq(Kfolds_lambda))
list_resultEstimation = as.list(seq(Kfolds_lambda))
vectorLambda = c()
for (i in seq(Kfolds_lambda)) {
which = foldid == i
list_vectorEstimate[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[!which, !which],
observedZ = observedZ[!which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
list_vectorEstimate_comp[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[which, which],
observedZ = observedZ[which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
whichna = which(!is.finite(list_vectorEstimate[[i]]))
if (length(which(is.finite(list_vectorEstimate[[i]]))) == 0) {
stop("Unable to estimate the conditional Kendall's tau in chooseLambdaCV. ",
"Possible explanation: h_lambda and/or the sample size are too small, ",
"or Kfolds_lambda is too large.")
} else if (length(whichna) > 0) {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]][-whichna]),
x = designMatrixZ[-whichna,])
} else {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]]),
x = designMatrixZ)
}
vectorLambda = c(vectorLambda, list_resultEstimation[[i]]$lambda)
}
h_lambda = NULL
for (i in seq(Kfolds_lambda)) {
which = foldid == i
list_vectorEstimate[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[!which, !which],
observedZ = observedZ[!which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
list_vectorEstimate_comp[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[which, which],
observedZ = observedZ[which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
whichna = which(!is.finite(list_vectorEstimate[[i]]))
if (length(which(is.finite(list_vectorEstimate[[i]]))) == 0) {
stop("Unable to estimate the conditional Kendall's tau in chooseLambdaCV. ",
"Possible explanation: h_lambda and/or the sample size are too small, ",
"or Kfolds_lambda is too large.")
} else if (length(whichna) > 0) {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]][-whichna]),
x = designMatrixZ[-whichna,])
} else {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]]),
x = designMatrixZ)
}
vectorLambda = c(vectorLambda, list_resultEstimation[[i]]$lambda)
}
kernel.name = "Epa"
vectorLambda = c()
for (i in seq(Kfolds_lambda)) {
which = foldid == i
list_vectorEstimate[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[!which, !which],
observedZ = observedZ[!which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
list_vectorEstimate_comp[[i]] = estimCKTNP(
matrixSignsPairs = matrixSignsPairs[which, which],
observedZ = observedZ[which], typeEstCKT = typeEstCKT,
h = h_lambda, ZToEstimate = ZToEstimate, kernel.name = kernel.name)
whichna = which(!is.finite(list_vectorEstimate[[i]]))
if (length(which(is.finite(list_vectorEstimate[[i]]))) == 0) {
stop("Unable to estimate the conditional Kendall's tau in chooseLambdaCV. ",
"Possible explanation: h_lambda and/or the sample size are too small, ",
"or Kfolds_lambda is too large.")
} else if (length(whichna) > 0) {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]][-whichna]),
x = designMatrixZ[-whichna,])
} else {
list_resultEstimation[[i]] =
glmnet::glmnet(y = Lambda(list_vectorEstimate[[i]]),
x = designMatrixZ)
}
vectorLambda = c(vectorLambda, list_resultEstimation[[i]]$lambda)
}
which(which)
is.vector(observedZ)
matrixSignsPairs_ = computeMatrixSignPairs(
vectorX1 = observedX1, vectorX2 = observedX2, typeEstCKT = typeEstCKT)
matrixSignsPairs = matrixSignsPairs_[!which, !which]
observedZ = observedZ[!which]
h = h_lambda
if (nrow(matrixSignsPairs) != ncol(matrixSignsPairs)){
stop("matrixSignsPairs must be a square matrix.")
} else if (nrow(matrixSignsPairs) != length(observedZ)){
stop(paste0("observedZ must have the same length ",
"as the number of rows of matrixSignsPairs."))
}
n_prime = length(ZToEstimate)
if (length(h) == 1) {
h_vect = rep(h, n_prime)
} else {
h_vect = h
}
if (progressBar) {
estimates = pbapply::pbapply(
X = array(1:n_prime), MARGIN = 1,
FUN = function(i) {CKT.kernelPointwise.univariate(
pointZ = ZToEstimate[i], matrixSignsPairs = matrixSignsPairs,
h = h_vect[i], vectorZ = observedZ,
kernel.name = kernel.name, typeEstCKT = typeEstCKT) } )
} else {
estimates = apply(
X = array(1:n_prime), MARGIN = 1,
FUN = function(i) {CKT.kernelPointwise.univariate(
pointZ = ZToEstimate[i], matrixSignsPairs = matrixSignsPairs,
h = h_vect[i], vectorZ = observedZ,
kernel.name = kernel.name, typeEstCKT = typeEstCKT) } )
}
progressBar = TRUE
if (progressBar) {
estimates = pbapply::pbapply(
X = array(1:n_prime), MARGIN = 1,
FUN = function(i) {CKT.kernelPointwise.univariate(
pointZ = ZToEstimate[i], matrixSignsPairs = matrixSignsPairs,
h = h_vect[i], vectorZ = observedZ,
kernel.name = kernel.name, typeEstCKT = typeEstCKT) } )
} else {
estimates = apply(
X = array(1:n_prime), MARGIN = 1,
FUN = function(i) {CKT.kernelPointwise.univariate(
pointZ = ZToEstimate[i], matrixSignsPairs = matrixSignsPairs,
h = h_vect[i], vectorZ = observedZ,
kernel.name = kernel.name, typeEstCKT = typeEstCKT) } )
}
#' # and estimated Kendall's tau (in red)
#' trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
#' plot(newZ, trueConditionalTau , col="black",
#'    type = "l", ylim = c(-1, 1))
#' lines(newZ, estimatedCKT_kendallReg, col = "red")
#'
#'
#'
#' @export
#'
CKT.kendallReg.fit <- function(
observedX1, observedX2, observedZ,
newDataZ, ZToEstimate = newDataZ,
designMatrixZ = cbind(ZToEstimate, ZToEstimate^2),
h_kernel,
Lambda = identity, Lambda_inv = identity,
lambda = NULL, Kfolds_lambda = 10, l_norm = 1, h_lambda = h_kernel, ...)
{
kernelEstCKT = CKT.kernel(
observedX1 = observedX1, observedX2 = observedX2,
observedZ = observedZ, newZ = ZToEstimate, h = h_kernel, ...)
whichFinite = which( is.finite(kernelEstCKT$estimatedCKT))
if (is.null(whichFinite)) {
stop("No kernel estimation successful. ",
"Maybe h_kernel is too small?")
}
fit = glmnet::glmnet(x = designMatrixZ[whichFinite, ],
y = Lambda(kernelEstCKT$estimatedCKT[whichFinite]),
family = "gaussian")
if (is.null(lambda)){
resultCV <- CKT.KendallReg.LambdaCV(
observedX1 = observedX1, observedX2 = observedX1,
observedZ = observedZ, ZToEstimate = ZToEstimate,
designMatrixZ = designMatrixZ,
typeEstCKT = 4, Lambda = Lambda, h_lambda = h_lambda, kernel.name = "Epa",
Kfolds_lambda = Kfolds_lambda, l_norm = l_norm)
lambda <- resultCV$lambdaCV
}
estimatedCKT = CKT.kendallReg.predict(fit = fit, newDataZ = newDataZ,
lambda = lambda, Lambda_inv = Lambda_inv)
return (list(estimatedCKT = estimatedCKT,
fit = fit))
}
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newDataZ = newZ, h_kernel = 0.07)
glmnet::predict.glmnet()
?glmnet::predict.glmnet
#' @references
#' Derumigny, A., & Fermanian, J. D. (2020).
#' On Kendall’s regression.
#' Journal of Multivariate Analysis, 178, 104610.
#'
#' @importFrom glmnet glmnet
#'
#' @return the predicted values
#'
#' @export
CKT.kendallReg.predict <- function(fit, newDataZ, lambda = NULL, Lambda_inv = identity){
return (Lambda_inv(glmnet::predict.glmnet(fit, newx = newDataZ,
s = lambda, type = "response")))
}
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.KendallReg.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newDataZ = newZ, h_kernel = 0.07)
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newDataZ = cbind(newZ, newZ^2), h_kernel = 0.07)
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
ZToEstimate = newZ,
newDataZ = cbind(newZ, newZ^2), h_kernel = 0.07)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kendallReg$estimatedCKT, col = "red")
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.kendallReg.fit(
observedX1 = X1, observedX2 = X2, observedZ = Z,
ZToEstimate = newZ,
newData = cbind(newZ, newZ^2), h_kernel = 0.07)
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
?missing
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.KendallReg.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
list(\(x) (x), \(x) (x^2), \(x) (x^3))
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
methodEstimation = "kendallReg"
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
?ifelse
ifelse(TRUE, 1:4, 1:6)
ifelse(methodEstimation == "kendallReg",
list(list(\(x) (x), \(x) (x^2), \(x) (x^3))),
list(list(identity)))
ifelse(methodEstimation == "kendallReg",
list(list(\(x) (x), \(x) (x^2), \(x) (x^3))),
list(list(identity)))[[1]]
if(methodEstimation == "kendallReg",
list(\(x) (x), \(x) (x^2), \(x) (x^3)),
list(identity))
if(methodEstimation == "kendallReg")
{list(\(x) (x), \(x) (x^2), \(x) (x^3))},
{list(identity)})
if(methodEstimation == "kendallReg")
{list(\(x) (x), \(x) (x^2), \(x) (x^3))}
else {list(identity)}
if(methodEstimation == "kendallReg")
{list(\(x) (x), \(x) (x^2), \(x) (x^3))} else
{list(identity)}
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
estimatedCKT_kendallReg <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "kendallReg", h = 0.07)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
lines(newZ, estimatedCKT_nNet, col = "coral")
lines(newZ, estimatedCKT_kernel, col = "skyblue")
lines(newZ, estimatedCKT_kernel, col = "darkgreen")
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
lines(newZ, estimatedCKT_nNet, col = "coral")
lines(newZ, estimatedCKT_kernel, col = "skyblue")
lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")
estimatedCKT_kendallReg
' lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")
'
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
lines(newZ, estimatedCKT_nNet, col = "coral")
lines(newZ, estimatedCKT_kernel, col = "skyblue")
lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")
nnet::predict.nnet
?nnet::predict.nnet
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.classif.tree.R', encoding = 'UTF-8')
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.classif.tree.R', encoding = 'UTF-8')
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
est_RF = CKT.fit.randomForest(datasetPairs = datasetP, n = N,
mindev = 0.008)
newData = seq(1,10,by = 0.1)
prediction = CKT.predict.randomForest(fit = est_RF,
newData = data.frame(x=newData))
# Comparison between true Kendall's tau (in red)
# and estimated Kendall's tau (in black)
plot(newData, prediction, type = "l", ylim = c(-1,1))
lines(newData, -0.9 + 1.8 * pnorm(newData, mean = 5, sd = 2), col="red")
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_knn <- CKT.predict.kNN(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1),
number_nn = c(50,80, 100, 120,200),
partition = 8)
2:(ncol(datasetPairs)-3)
ncol(datasetPairs)
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.classif.kNN.R', encoding = 'UTF-8')
estimatedCKT_knn <- CKT.predict.kNN(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1),
number_nn = c(50,80, 100, 120,200),
partition = 8)
eval(designMatrix)
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.classif.kNN.R', encoding = 'UTF-8')
estimatedCKT_knn <- CKT.predict.kNN(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1),
number_nn = c(50,80, 100, 120,200),
partition = 8)
designMatrix
datasetPairs
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.classif.kNN.R', encoding = 'UTF-8')
estimatedCKT_knn <- CKT.predict.kNN(
datasetPairs = datasetP,
newData = matrix(newZ,ncol = 1),
number_nn = c(50,80, 100, 120,200),
partition = 8)
