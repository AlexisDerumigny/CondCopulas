estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
library(CondCopulas)
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = matrix(newZ, ncol = 1),
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = matrix(newZ, ncol = 1),
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
?sapply
source('D:/Work/Packages/CondCopulas/CondCopulas/R/estimationCKT.R', encoding = 'UTF-8')
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = matrix(newZ, ncol = 1),
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = matrix(newZ, ncol = 1),
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 8
)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = matrix(newZ, ncol = 1),
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 4
)
lines(newZ, estimatedCKT_kNN, col = "purple")
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 4
)
lines(newZ, estimatedCKT_kNN, col = "purple")
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
estimatedCKT_nNet <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "neuralNetwork", h = 0.07,
)
observedX1 = X1
observedX2 = X2
observedZ = Z
newData = newZ
' # We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_knn <- CKT.fit.nNets(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1))
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_knn <- CKT.fit.nNets(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1))
'''''
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_knn <- CKT.fit.nNets(
datasetPairs = datasetPairs,
newData = matrix(newZ,ncol = 1))
estimatedCKT_knn <- CKT.fit.nNets(
datasetPairs = datasetPairs)
#' # Comparison between true Kendall's tau (in black)
#' # and estimated Kendall's tau (in red)
#' trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
#' plot(newZ, trueConditionalTau , col="black",
#'    type = "l", ylim = c(-1, 1))
#' lines(newZ, estimatedCKT_knn$estimatedCKT, col = "red")
#'
#'
#' @export
#'
CKT.fit.nNets <- function(datasetPairs,
designMatrix = datasetPairs[,2:(ncol(datasetPairs)-3),drop=FALSE],
vecSize = rep(3, times = 10),
nObs_per_NN = 0.9*nrow(designMatrix),
verbose = 1)
{
# Initialization
length_list_nnet = length(vecSize)
n = nrow(designMatrix)
list_nnet = as.list(seq(length_list_nnet))
for (i in 1:length_list_nnet)
{
# We choose at random the initial sample
sampleId = sample.int(n = n, size = nObs_per_NN)
# We compute the data matrix from this sample
whichPairs = which( (datasetPairs[,"iUsed"] %in% sampleId)
& (datasetPairs[,"jUsed"] %in% sampleId) )
datasetPairs_sample = datasetPairs[whichPairs,]
designMatrix_sample = cbind(designMatrix[whichPairs,])
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample$kernel.value,
size = vecSize[i], maxit = 1000)
list_nnet[[i]] <- fit_nnet
if (verbose >= 1)
{
cat(i) ; cat(" -- size = ") ; cat(vecSize[i]) ; cat("\n")
}
}
return(list(list_nnet = list_nnet))
}
estimatedCKT_knn <- CKT.fit.nNets(
datasetPairs = datasetPairs)
datasetPairs = datasetPairs
designMatrix = datasetPairs[,2:(ncol(datasetPairs)-3),drop=FALSE]
vecSize = rep(3, times = 10)
nObs_per_NN = 0.9*nrow(designMatrix)
verbose = 1
# Initialization
length_list_nnet = length(vecSize)
n = nrow(designMatrix)
list_nnet = as.list(seq(length_list_nnet))
for (i in 1:length_list_nnet)
{
# We choose at random the initial sample
sampleId = sample.int(n = n, size = nObs_per_NN)
# We compute the data matrix from this sample
whichPairs = which( (datasetPairs[,"iUsed"] %in% sampleId)
& (datasetPairs[,"jUsed"] %in% sampleId) )
datasetPairs_sample = datasetPairs[whichPairs,]
designMatrix_sample = cbind(designMatrix[whichPairs,])
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample$kernel.value,
size = vecSize[i], maxit = 1000)
list_nnet[[i]] <- fit_nnet
if (verbose >= 1)
{
cat(i) ; cat(" -- size = ") ; cat(vecSize[i]) ; cat("\n")
}
}
i
# We choose at random the initial sample
sampleId = sample.int(n = n, size = nObs_per_NN)
# We compute the data matrix from this sample
whichPairs = which( (datasetPairs[,"iUsed"] %in% sampleId)
& (datasetPairs[,"jUsed"] %in% sampleId) )
datasetPairs_sample = datasetPairs[whichPairs,]
designMatrix_sample = cbind(designMatrix[whichPairs,])
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample$kernel.value,
size = vecSize[i], maxit = 1000)
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample[, "kernel.value"],
size = vecSize[i], maxit = 1000)
for (i in 1:length_list_nnet)
{
# We choose at random the initial sample
sampleId = sample.int(n = n, size = nObs_per_NN)
# We compute the data matrix from this sample
whichPairs = which( (datasetPairs[,"iUsed"] %in% sampleId)
& (datasetPairs[,"jUsed"] %in% sampleId) )
datasetPairs_sample = datasetPairs[whichPairs,]
designMatrix_sample = cbind(designMatrix[whichPairs,])
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample[, "kernel.value"],
size = vecSize[i], maxit = 1000)
list_nnet[[i]] <- fit_nnet
if (verbose >= 1)
{
cat(i) ; cat(" -- size = ") ; cat(vecSize[i]) ; cat("\n")
}
}
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_nets <- CKT.fit.nNets(
datasetPairs = datasetPairs)
#' X2 = qnorm(simCopula[,2])
#'
#' newZ = seq(2,10,by = 0.1)
#' datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
#' estimatedCKT_nets <- CKT.fit.nNets(
#'   datasetPairs = datasetPairs)
#'
#'
#' @export
#'
CKT.fit.nNets <- function(datasetPairs,
designMatrix = datasetPairs[,2:(ncol(datasetPairs)-3),drop=FALSE],
vecSize = rep(3, times = 10),
nObs_per_NN = 0.9*nrow(designMatrix),
verbose = 1)
{
# Initialization
length_list_nnet = length(vecSize)
n = nrow(designMatrix)
list_nnet = as.list(seq(length_list_nnet))
for (i in 1:length_list_nnet)
{
# We choose at random the initial sample
sampleId = sample.int(n = n, size = nObs_per_NN)
# We compute the data matrix from this sample
whichPairs = which( (datasetPairs[,"iUsed"] %in% sampleId)
& (datasetPairs[,"jUsed"] %in% sampleId) )
datasetPairs_sample = datasetPairs[whichPairs,]
designMatrix_sample = cbind(designMatrix[whichPairs,])
fit_nnet = nnet::nnet(as.factor(datasetPairs_sample[ ,1]) ~ .,
data = designMatrix_sample, trace = (verbose == 2),
weights = datasetPairs_sample[, "kernel.value"],
size = vecSize[i], maxit = 1000)
list_nnet[[i]] <- fit_nnet
if (verbose >= 1)
{
cat(i) ; cat(" -- size = ") ; cat(vecSize[i]) ; cat("\n")
}
}
return(list(list_nnet = list_nnet))
}
estimatedCKT_nets <- CKT.fit.nNets(
datasetPairs = datasetPairs)
estimatedCKT_nNets <- CKT.predict.nNets(fitCKT_nets, matrix(newZ, ncol = 1))
fitCKT_nets <- CKT.fit.nNets(datasetPairs = datasetPairs)
fitCKT_nNets <- CKT.fit.nNets(datasetPairs = datasetPairs)
estimatedCKT_nNets <- CKT.predict.nNets(fitCKT_nNets, matrix(newZ, ncol = 1))
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_nNets, col = "red")
estimatedCKT_nNets
estimatedCKT_nNets <- CKT.predict.nNets(fitCKT_nNets, matrix(newZ, ncol = 1))
newData = matrix(newZ, ncol = 1)
fit = fitCKT_nNets
aggregationMethod = "mean"
#' # and estimated Kendall's tau (in red)
#' trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
#' plot(newZ, trueConditionalTau , col="black",
#'    type = "l", ylim = c(-1, 1))
#' lines(newZ, estimatedCKT_nNets, col = "red")
#'
#' @importFrom nnet nnet
#'
#' @export
#'
CKT.predict.nNets <- function(fit, newData, aggregationMethod = "mean")
{
length_list_nn = length(fit)
length_toPredict = length(newData[,1])
matrixPrediction = matrix(nrow = length_toPredict, ncol = length_list_nn)
# Prediction
if (ncol(newData) > 1) {
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
} else {
colnames(newData) <- "V1"
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
}
# Aggregation
prediction = rep(NA, length_toPredict)
if (aggregationMethod == "mean")
{
prediction = rep(0, length_toPredict)
for (i_nn in 1:length_list_nn)
{
prediction = prediction + matrixPrediction[, i_nn]
}
prediction = prediction / length_list_nn
} else if (aggregationMethod == "median") {
for (iPredict in 1:length_toPredict)
{
prediction[iPredict] = stats::median(matrixPrediction[iPredict, ])
}
}
return(prediction)
}
length_list_nn = length(fit)
length_toPredict = length(newData[,1])
matrixPrediction = matrix(nrow = length_toPredict, ncol = length_list_nn)
# Prediction
if (ncol(newData) > 1) {
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
} else {
colnames(newData) <- "V1"
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
}
fit[[i_nn]]
length_list_nn
library(CondCopulas)
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
fitCKT_nNets <- CKT.fit.nNets(datasetPairs = datasetPairs)
estimatedCKT_nNets <- CKT.predict.nNets(
fit = fitCKT_nNets, newData = matrix(newZ, ncol = 1))
# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_nNets, col = "red")
fitCKT_nNets <- CKT.fit.nNets(datasetPairs = datasetPairs)
2:(ncol(datasetPairs)-3)
datasetPairs
fitCKT_nNets <- CKT.fit.nNets(datasetPairs = datasetP)
estimatedCKT_nNets <- CKT.predict.nNets(
fit = fitCKT_nNets, newData = matrix(newZ, ncol = 1))
# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_nNets, col = "red")
#' # and estimated Kendall's tau (in red)
#' trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
#' plot(newZ, trueConditionalTau , col="black",
#'    type = "l", ylim = c(-1, 1))
#' lines(newZ, estimatedCKT_nNets, col = "red")
#'
#' @importFrom nnet nnet
#'
#' @export
#'
CKT.predict.nNets <- function(fit, newData, aggregationMethod = "mean")
{
length_list_nn = length(fit)
length_toPredict = length(newData[,1])
matrixPrediction = matrix(nrow = length_toPredict, ncol = length_list_nn)
# Prediction
if (ncol(newData) > 1) {
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
} else {
colnames(newData) <- "V1"
for (i_nn in 1:length_list_nn)
{
matrixPrediction[, i_nn] = predict(fit[[i_nn]], newData)
}
}
# Aggregation
prediction = rep(NA, length_toPredict)
if (aggregationMethod == "mean")
{
prediction = rep(0, length_toPredict)
for (i_nn in 1:length_list_nn)
{
prediction = prediction + matrixPrediction[, i_nn]
}
prediction = prediction / length_list_nn
} else if (aggregationMethod == "median") {
for (iPredict in 1:length_toPredict)
{
prediction[iPredict] = stats::median(matrixPrediction[iPredict, ])
}
}
predictCKt = 2 * prediction - 1
return(predictCKt)
}
estimatedCKT_nNets <- CKT.predict.nNets(
fit = fitCKT_nNets, newData = matrix(newZ, ncol = 1))
# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_nNets, col = "red")
library(CondCopulas)
estimatedCKT_nNet <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "neuralNetwork", h = 0.07,
)
# We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])
newZ = seq(2,10,by = 0.1)
estimatedCKT_tree <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "tree", h = 0.07)
estimatedCKT_rf <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "randomForest", h = 0.07)
estimatedCKT_GLM <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "logit", h = 0.07,
listPhi = list(\(x) (x), \(x) (x^2), \(x) (x^3)) )
estimatedCKT_kNN <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "nearestNeighbors", h = 0.07,
number_nn = c(50,80, 100, 120,200),
partition = 4
)
estimatedCKT_nNet <- CKT.estimate(
observedX1 = X1, observedX2 = X2, observedZ = Z,
newData = newZ,
methodEstimation = "neuralNetwork", h = 0.07,
)
# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in other colors)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
lines(newZ, estimatedCKT_nNet, col = "yellow")
lines(newZ, estimatedCKT_nNet, col = "coral")
